"use client";

// import type { Dispatch, SetStateAction } from 'react'; // No longer need SetStateAction directly if only updateGameStateAndCheckQuests is used
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import type { GameState, ResourceSet } from '@/types/game';
import { BUILDING_TYPES, ACTION_ICONS, TURN_EVENTS } from '@/config/game-config';
import { useToast } from '@/hooks/use-toast';
// No longer needed here: import { checkAndCompleteQuests as checkAndCompleteQuestsAction } from '@/app/actions/quest-actions';

interface GameActionsProps {
  gameState: GameState;
  updateGameStateAndCheckQuests: (newStateOrUpdater: GameState | ((prevState: GameState) => GameState)) => Promise<void>;
}

export function GameActions({ gameState, updateGameStateAndCheckQuests }: GameActionsProps) {
  const { toast } = useToast();

  const handleNextTurn = async () => {
    const turnToAnnounce = gameState.currentTurn + 1;

    const updaterFunction = (prevGameState: GameState): GameState => {
      let newResources = { ...prevGameState.resources };
      let totalUpkeep: Partial<ResourceSet> = {};
      let totalProduction: Partial<ResourceSet> = {};

      prevGameState.structures.forEach(structure => {
        const type = BUILDING_TYPES[structure.typeId];
        if (type) {
          Object.entries(type.upkeep).forEach(([res, val]) => {
            totalUpkeep[res as keyof ResourceSet] = (totalUpkeep[res as keyof ResourceSet] || 0) + val;
          });
          Object.entries(type.production).forEach(([res, val]) => {
            totalProduction[res as keyof ResourceSet] = (totalProduction[res as keyof ResourceSet] || 0) + val;
          });
        }
      });
      
      Object.entries(totalUpkeep).forEach(([res, val]) => {
        newResources[res as keyof ResourceSet] = Math.max(0, (newResources[res as keyof ResourceSet] || 0) - val);
      });

      Object.entries(totalProduction).forEach(([res, val]) => {
        newResources[res as keyof ResourceSet] = (newResources[res as keyof ResourceSet] || 0) + val;
      });

      const randomEventIndex = Math.floor(Math.random() * TURN_EVENTS.length);
      const randomEvent = TURN_EVENTS[randomEventIndex];
      
      return {
        ...prevGameState,
        currentTurn: prevGameState.currentTurn + 1,
        resources: newResources,
        currentEvent: randomEvent,
      };
    };
    
    await updateGameStateAndCheckQuests(updaterFunction);
      
    // The toast for the turn event itself. Quest toasts are handled by the parent.
    // We use turnToAnnounce as gameState might have already updated due to the async nature.
    // The currentEvent will be set by the updaterFunction and then by the parent's setGameState.
    // To get the *actual* event for *this* turn to toast, we might need to read it from the state *after* update.
    // However, updateGameStateAndCheckQuests doesn't return the final state directly.
    // For simplicity, we'll toast based on the random event picked before the state update.
    // A more robust solution would be for updateGameStateAndCheckQuests to return the final event.
    // Or, the toast for event could also be handled in page.tsx.
    // For now, let's assume the turn event message is generated and can be toasted here.
    // The random event is part of the 'intermediateState' logic which is now inside updaterFunction.
    // To display the correct event, we'd ideally want the `updatedGameState` from `page.tsx`
    // or have `updateGameStateAndCheckQuests` return it.
    // Simplification: toast the general turn advance. Specific event toast could be enhanced.
    // We use `turnToAnnounce` for the toast.
    // The actual event `gameState.currentEvent` will be updated by the parent, so if we toast here,
    // it might show the *previous* turn's event if not careful.
    // Let's retrieve the event generated by updaterFunction to toast it accurately.

    // To get the event for the toast, we re-run the part of logic that generates it.
    // This is not ideal, but avoids more complex state passing for now.
    const tempRandomEvent = TURN_EVENTS[Math.floor(Math.random() * TURN_EVENTS.length)]; // This will be different from the one set in state.
                                                                                        // This is problematic.
    // The toast for the currentEvent should ideally be based on the state *after* it's updated.
    // Since `updateGameStateAndCheckQuests` in parent handles this, let parent also handle event toast.
    // Or, we pass the specific event to the parent for toasting.

    // For now, just toast turn advancement. Event display is handled by UI reading gameState.currentEvent.
    toast({
      title: `Turn ${turnToAnnounce}`,
      // description: "Events unfolded, check the realm overview.", // Generic message
      // The actual event description is shown in the UI based on gameState.currentEvent
      // For the toast specifically, we'd need to ensure the event is correctly passed or determined.
      // The parent's `updateGameStateAndCheckQuests` will update `gameState.currentEvent`.
      // Let's keep the toast simple, or move event-specific toasting to page.tsx
      // For now, the current `gameState.currentEvent` that is displayed below the button
      // will update correctly after the parent `setGameState` runs.
      description: "A new turn begins...",
    });
  };

  return (
    <Card className="shadow-lg mt-4">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <ACTION_ICONS.NextTurn className="h-6 w-6 text-accent" />
          Realm Actions
        </CardTitle>
      </CardHeader>
      <CardContent className="flex flex-col space-y-2">
        <Button onClick={handleNextTurn} className="w-full" disabled={!gameState.generatedWorldMap}>
          <ACTION_ICONS.NextTurn className="mr-2 h-5 w-5" />
          Advance to Next Turn (Turn {gameState.currentTurn})
        </Button>
        {gameState.currentEvent && (
          <p className="text-sm text-muted-foreground p-2 border rounded-md bg-muted/30">
            <span className="font-semibold">Latest Event:</span> {gameState.currentEvent}
          </p>
        )}
      </CardContent>
    </Card>
  );
}
